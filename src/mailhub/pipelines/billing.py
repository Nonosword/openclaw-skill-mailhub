from __future__ import annotations

import hashlib
import json
import re
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import yaml

from ..config import Settings
from ..store import DB
from ..utils.time import utc_now_iso, today_yyyy_mm_dd_utc
from ..utils.pdf import extract_pdf


def _load_yaml(path: Path) -> Dict[str, Any]:
    return yaml.safe_load(path.read_text(encoding="utf-8"))


def billing_detect(since: str = "30d") -> Dict[str, Any]:
    """
    MVP:
    - relies on already ingested messages in DB
    - tags 'bills' already generated by triage; here we create statement candidates
    """
    s = Settings.load()
    db = DB(s.db_path)
    db.init()

    # Ensure today's triage ran
    from .triage import triage_day
    triage_day("today")

    day = today_yyyy_mm_dd_utc()
    msgs = db.get_messages_by_date(day)
    detected: List[Dict[str, Any]] = []

    for m in msgs:
        tags = db.get_tags_for_message(m["id"])
        top = tags[0]["tag"] if tags else "other"
        if top != "bills":
            continue
        sid = _statement_id(m["id"], m.get("subject") or "")
        detected.append({"statement_id": sid, "message_id": m["id"], "subject": m.get("subject")})

    return {"ok": True, "day": day, "detected": detected}


def billing_analyze(statement_id: str) -> Dict[str, Any]:
    """
    MVP:
    - find statement candidate by id from today's messages
    - extract minimal info from subject/body
    - if message has PDF attachments, parse text via pdfplumber
    """
    s = Settings.load()
    db = DB(s.db_path)
    db.init()

    day = today_yyyy_mm_dd_utc()
    msgs = db.get_messages_by_date(day)

    target = None
    for m in msgs:
        sid = _statement_id(m["id"], m.get("subject") or "")
        if sid == statement_id:
            target = m
            break
    if not target:
        raise RuntimeError("Statement not found for today in MVP. (Extend by searching wider date range.)")

    atts = _list_attachments(db, target["id"])
    pdf_text = ""
    for a in atts:
        if (a.get("content_type") or "").lower() == "application/pdf" or (a.get("filename") or "").lower().endswith(".pdf"):
            ex = extract_pdf(a["stored_path"])
            pdf_text = ex.text
            break

    text_for_extract = (target.get("body_text") or "") + "\n\n" + (pdf_text or "")
    issuer = _guess_issuer(target.get("from_addr") or "", target.get("subject") or "")
    month = _guess_month(target.get("subject") or "", text_for_extract)

    # totals (very heuristic)
    total_due, due_date, currency = _extract_amounts(text_for_extract)

    extracted = {
        "issuer": issuer,
        "statement_month": month,
        "total_due": total_due,
        "due_date": due_date,
        "currency": currency,
        "signals": {"from": target.get("from_addr"), "subject": target.get("subject")},
    }

    db.upsert_statement(
        {
            "id": statement_id,
            "message_id": target["id"],
            "issuer": issuer,
            "statement_month": month,
            "total_due": total_due,
            "due_date": due_date,
            "currency": currency,
            "extracted_json": json.dumps(extracted),
            "created_at": utc_now_iso(),
        }
    )

    return {"ok": True, "statement_id": statement_id, "extracted": extracted}


def billing_month(month: str) -> Dict[str, Any]:
    """
    Rollup for YYYY-MM.
    """
    s = Settings.load()
    db = DB(s.db_path)
    db.init()

    sts = db.list_statements_for_month(month)
    total = 0.0
    by_issuer: Dict[str, float] = {}
    for st in sts:
        amt = float(st.get("total_due") or 0.0)
        total += amt
        issuer = st.get("issuer") or "unknown"
        by_issuer[issuer] = by_issuer.get(issuer, 0.0) + amt

    top = sorted(by_issuer.items(), key=lambda x: x[1], reverse=True)
    return {"ok": True, "month": month, "statement_count": len(sts), "total_due": total, "by_issuer": top, "statements": sts}


def _statement_id(message_id: str, subject: str) -> str:
    h = hashlib.sha256((message_id + "|" + subject).encode("utf-8")).hexdigest()[:16]
    return f"st_{h}"


def _guess_issuer(from_addr: str, subject: str) -> str:
    s = (from_addr + " " + subject).lower()
    for k in ["amex", "chase", "citi", "hsbc", "boa", "capital one", "discover", "visa", "mastercard"]:
        if k in s:
            return k
    return "unknown"


def _guess_month(subject: str, body: str) -> Optional[str]:
    # Look for YYYY-MM patterns
    m = re.search(r"(20\d{2})[-/\.](\d{1,2})", subject + " " + body)
    if m:
        yyyy = m.group(1)
        mm = int(m.group(2))
        return f"{yyyy}-{mm:02d}"
    return None


def _extract_amounts(text: str) -> Tuple[Optional[float], Optional[str], Optional[str]]:
    # Very rough extraction:
    # - currency: $ or USD
    currency = "USD" if ("$" in text or "USD" in text.upper()) else None
    # amount: first big-looking amount
    m = re.search(r"\$?\s*([0-9]{1,3}(?:,[0-9]{3})*(?:\.[0-9]{2})?)", text)
    amt = None
    if m:
        try:
            amt = float(m.group(1).replace(",", ""))
        except Exception:
            amt = None
    # due date: YYYY-MM-DD
    d = re.search(r"(20\d{2}-\d{2}-\d{2})", text)
    due = d.group(1) if d else None
    return amt, due, currency


def _list_attachments(db: DB, message_id: str) -> List[Dict[str, Any]]:
    con = db.connect()
    try:
        rows = con.execute("SELECT * FROM attachments WHERE message_id=? ORDER BY id DESC", (message_id,)).fetchall()
        return [dict(r) for r in rows]
    finally:
        con.close()